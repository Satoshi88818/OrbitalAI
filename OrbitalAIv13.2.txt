import argparse
import logging
import math
import random
import os
import requests
from dataclasses import dataclass
from typing import Tuple, List, Optional

import torch
import torch.nn as nn
import torch.nn.functional as F
import torchvision
import torchvision.transforms as transforms
import matplotlib.pyplot as plt

logging.basicConfig(level=logging.INFO, format="%(asctime)s [%(levelname)s] %(name)s: %(message)s")
logger = logging.getLogger("orbital-ai-v13.2")

class OrbitalAIError(Exception): pass
class EnduranceFailure(OrbitalAIError): pass
class ThermalRunaway(OrbitalAIError): pass


@dataclass
class Config:
    array_size: int = 128
    node_size_nm: int = 28
    base_seu_per_hour: float = 1e-5
    hardening_factor: float = 8.0
    base_power_w: float = 2.5
    leakage_base_w: float = 0.8
    thermal_resistance: float = 8.0
    thermal_time_constant: float = 180.0
    max_temp_c: float = 85.0
    radiator_area_m2: float = 0.05
    solar_abs: float = 0.15
    earth_ir_w_m2: float = 237.0
    albedo: float = 0.3
    solar_constant: float = 1366.0
    # === v13.2 ACTIVE THERMAL CONTROL ===
    min_operational_temp_c: float = -5.0
    heater_max_w: float = 2.0
    louver_min_eps: float = 0.25
    louver_max_eps: float = 0.92
    thermal_setpoint_c: float = 30.0
    # === v13.2 VARIABLE BETA ANGLE ===
    beta_amplitude_deg: float = 52.0
    beta_period_days: float = 52.0
    # === v13.2 CONSTELLATION RADIATOR SHARING ===
    inter_node_conductance_wk: float = 8.0
    # =============================================
    scrub_interval_orbits: int = 8
    scrub_efficiency: float = 0.97
    freq_ghz: float = 0.8
    orbit_period_s: float = 95 * 60
    dynamic_coeff: float = 5.5
    freq_exp: float = 1.85


class GOESProtonFlux: ...  # unchanged from v13.1


class Radiator:
    def __init__(self, config: Config):
        self.config = config
        self.area = config.radiator_area_m2
        self.alpha = config.solar_abs

    def net_external_power(self, T_k: float, sun_fraction: float, eps: float) -> float:
        sigma = 5.67e-8
        radiated = eps * sigma * self.area * (T_k ** 4)
        absorbed_solar = sun_fraction * self.alpha * self.config.solar_constant * self.area * 0.25
        absorbed_albedo = sun_fraction * self.alpha * self.config.albedo * 0.35 * self.config.solar_constant * self.area * 0.25
        absorbed_earth = self.alpha * self.config.earth_ir_w_m2 * self.area * 0.4
        return absorbed_solar + absorbed_albedo + absorbed_earth - radiated


def get_sun_fraction(beta_deg: float, config: Config) -> float:
    """First-principles LEO sun/eclipse fraction from β-angle"""
    beta_crit = 55.0
    if abs(beta_deg) >= beta_crit:
        return 1.0
    eclipse_frac = 0.37 * (1.0 - abs(beta_deg) / beta_crit)
    return max(0.63, 1.0 - eclipse_frac)


# SystolicArray, RadHardWeight, RHBDLayer, OrbitalTinyCNN, RadHardOptimizer unchanged from v13.1


class OrbitalAIChip:
    def __init__(self, config: Config, thermal_bus=None):
        self.config = config
        self.array = SystolicArray(config.array_size, self)
        self.rhbd = RHBDLayer(config)
        self.radiator = Radiator(config)
        self.temp_c = -18.0
        self.total_cycles = 0
        self.mission_time_s = 0.0
        self.thermal_capacity = config.thermal_time_constant / config.thermal_resistance
        self.heater_power = 0.0
        self.current_eps = config.louver_max_eps
        self.thermal_bus = thermal_bus

    def update_thermal(self, dt_s: float, sun_fraction: float, beta_deg: float):
        T_k = self.temp_c + 273.15

        # === Active louvers (proportional control) ===
        error = self.temp_c - self.config.thermal_setpoint_c
        louver_factor = max(0.0, min(1.0, 0.5 + error * 0.025))
        self.current_eps = self.config.louver_min_eps + louver_factor * (self.config.louver_max_eps - self.config.louver_min_eps)

        # === Heaters (prevent cold soak) ===
        self.heater_power = 0.0
        if self.temp_c < self.config.min_operational_temp_c:
            self.heater_power = self.config.heater_max_w * (self.config.min_operational_temp_c - self.temp_c) / 10.0
            self.heater_power = min(self.heater_power, self.config.heater_max_w)

        leakage = self.config.leakage_base_w * math.exp(0.07 * max(0.0, self.temp_c - 25.0))
        p_gen = self.config.base_power_w + leakage + 0.8 + self.heater_power

        p_ext_net = self.radiator.net_external_power(T_k, sun_fraction, self.current_eps)
        p_net = p_gen + p_ext_net

        # === Constellation radiator sharing ===
        if self.thermal_bus:
            avg_temp = sum(n.temp_c for n in self.thermal_bus.nodes) / len(self.thermal_bus.nodes)
            p_share = self.config.inter_node_conductance_wk * (avg_temp - self.temp_c)
            p_net += p_share

        dT = p_net * dt_s / self.thermal_capacity
        self.temp_c += dT
        if self.temp_c > self.config.max_temp_c:
            raise ThermalRunaway(f"Thermal runaway at {self.temp_c:.1f}°C after {self.mission_time_s/86400:.1f} days")
        self.temp_c = max(self.temp_c, -70.0)


# FPGAExporter unchanged


class OrbitalTrainer:
    def __init__(self, hardware, lr: float = 0.009):
        self.is_constellation = isinstance(hardware, ODCConstellation)
        self.nodes = hardware.nodes if self.is_constellation else [hardware]
        self.lr = lr
        self.models = [OrbitalTinyCNN(node) for node in self.nodes]
        self.optimizers = [RadHardOptimizer([w.weights for w in m.get_radhard_weights()], lr=lr, chip=node)
                           for m, node in zip(self.models, self.nodes)]
        self.orbit_count = 0
        self.mission_time_s = 0.0

    def train_epoch(self, train_X: torch.Tensor, train_y: torch.Tensor, batch_size: int = 128):
        model = self.models[0]
        chip = self.nodes[0]
        opt = self.optimizers[0]

        model.train()
        perm = torch.randperm(len(train_X))
        X, y = train_X[perm], train_y[perm]

        for i in range(0, len(X), batch_size):
            bx = X[i:i+batch_size]
            by = y[i:i+batch_size]
            opt.zero_grad()
            outputs = model(bx, chip.mission_time_s)
            loss = F.cross_entropy(outputs, by)
            loss.backward()
            opt.step()
            chip.mission_time_s += 0.045
            self.mission_time_s = chip.mission_time_s

        epoch_compute_s = len(X) / batch_size * 0.045
        days = chip.mission_time_s / 86400
        beta = chip.config.beta_amplitude_deg * math.sin(2 * math.pi * days / chip.config.beta_period_days)
        sun_fraction = get_sun_fraction(beta, chip.config)
        chip.update_thermal(epoch_compute_s, sun_fraction, beta)

        self.orbit_count += 1
        if self.orbit_count % chip.config.scrub_interval_orbits == 0:
            model.scrub()
            chip.rhbd.scrub()

        return loss.item()

    def train(self, train_X, train_y, epochs: int = 30, batch_size: int = 128):
        logger.info(f"Starting v13.2 rad-hard training with active thermal control & β-angle cycling...")
        for epoch in range(epochs):
            loss = self.train_epoch(train_X, train_y, batch_size)
            if epoch % 5 == 0 or epoch == epochs - 1:
                chip = self.nodes[0]
                logger.info(f"Epoch {epoch+1:2d}/{epochs} | Loss: {loss:.4f} | T: {chip.temp_c:.1f}°C | Heater: {chip.heater_power:.2f}W | ε: {chip.current_eps:.3f}")


class ODCConstellation:
    def __init__(self, num_nodes: int = 3, config: Config = None):
        self.config = config or Config()
        self.nodes = [OrbitalAIChip(self.config, thermal_bus=self) for _ in range(num_nodes)]


class MissionSimulator:
    def __init__(self, model: OrbitalTinyCNN, chip: OrbitalAIChip):
        self.model = model
        self.chip = chip
        self.config = chip.config

    @torch.no_grad()
    def evaluate(self, test_X: torch.Tensor, test_y: torch.Tensor, batch_size: int = 256) -> float:
        self.model.eval()
        correct = 0
        total = len(test_y)
        for i in range(0, len(test_X), batch_size):
            bx = test_X[i:i+batch_size]
            by = test_y[i:i+batch_size]
            out = self.model(bx, self.chip.mission_time_s)
            correct += (out.argmax(dim=1) == by).sum().item()
        return 100.0 * correct / total

    def run(self, test_X: torch.Tensor, test_y: torch.Tensor, years: float = 5.0):
        total_seconds = years * 365.25 * 86400
        orbits_total = int(total_seconds / self.config.orbit_period_s)
        time_step_s = 60.0

        time_y, acc_deg, temp_deg, beta_deg_list = [], [], [], []
        orbit = 0

        logger.info(f"Starting 5-year LEO mission with full v13.2 active thermal + β + constellation sharing...")

        while orbit < orbits_total:
            days = self.chip.mission_time_s / 86400
            beta = self.config.beta_amplitude_deg * math.sin(2 * math.pi * days / self.config.beta_period_days)
            sun_fraction = get_sun_fraction(beta, self.config)

            orbit_time_left = self.config.orbit_period_s
            while orbit_time_left > 0:
                dt = min(time_step_s, orbit_time_left)
                self.chip.update_thermal(dt, sun_fraction, beta)
                self.chip.mission_time_s += dt
                orbit_time_left -= dt

            for w in self.model.get_radhard_weights():
                w.corrupt(self.config.orbit_period_s, self.chip.mission_time_s)

            if (orbit + 1) % self.config.scrub_interval_orbits == 0:
                self.model.scrub()
                self.chip.rhbd.scrub()

            acc = self.evaluate(test_X, test_y)
            years_elapsed = self.chip.mission_time_s / (365.25 * 86400)

            time_y.append(years_elapsed)
            acc_deg.append(acc)
            temp_deg.append(self.chip.temp_c)
            beta_deg_list.append(beta)

            flux = self.chip.rhbd.proton.get_flux_multiplier(self.chip.mission_time_s)
            logger.info(f"→ {years_elapsed:.2f} yr | Acc: {acc:.2f}% | T: {self.chip.temp_c:.1f}°C | β: {beta:+5.1f}° | Heater: {self.chip.heater_power:.2f}W | ε: {self.chip.current_eps:.3f} | Flux: {flux:.1f}x")

            orbit += 1

        # === Triple-axis plot ===
        fig, ax1 = plt.subplots(figsize=(13, 7))
        ax1.set_xlabel('Mission Time (years)')
        ax1.set_ylabel('Top-1 Accuracy (%)', color='tab:red')
        ax1.plot(time_y, acc_deg, 'r-', linewidth=2.5, label='Accuracy')
        ax1.tick_params(axis='y', labelcolor='tab:red')

        ax2 = ax1.twinx()
        ax2.set_ylabel('Chip Temperature (°C)', color='tab:blue')
        ax2.plot(time_y, temp_deg, 'b--', linewidth=2, label='Temperature')
        ax2.tick_params(axis='y', labelcolor='tab:blue')

        ax3 = ax1.twinx()
        ax3.spines.right.set_position(("axes", 1.15))
        ax3.set_ylabel('β Angle (°)', color='tab:green')
        ax3.plot(time_y, beta_deg_list, 'g-.', linewidth=1.5, label='β Angle')
        ax3.tick_params(axis='y', labelcolor='tab:green')

        plt.title('Orbital AI v13.2 — 5-Year LEO with Active Thermal Control, Variable β, & Constellation Radiator Sharing')
        fig.legend(loc='upper right', bbox_to_anchor=(0.85, 0.85))
        plt.grid(True, alpha=0.35)
        plt.tight_layout()
        plt.savefig('orbital_5year_v13_2_thermal_beta.png', dpi=300, bbox_inches='tight')
        logger.info("✅ v13.2 full thermal-orbital-constellation simulation complete.")
        logger.info("   Plot saved as orbital_5year_v13_2_thermal_beta.png")
        return time_y, acc_deg, temp_deg


def run_demo(args):
    config = Config()
    logger.info("=== Orbital AI v13.2 — Active Thermal + Variable β + Constellation Radiator Sharing ===")
    logger.info(f"Nodes: {args.nodes} | Real GOES: True | Active Thermal: ON | β cycling: ON")

    transform = transforms.Compose([transforms.ToTensor(), transforms.Normalize((0.4914, 0.4822, 0.4465), (0.2023, 0.1994, 0.2010))])
    train_set = torchvision.datasets.CIFAR10(root='./data', train=True, download=True, transform=transform)
    test_set = torchvision.datasets.CIFAR10(root='./data', train=False, download=True, transform=transform)

    train_X = torch.stack([train_set[i][0] for i in torch.randperm(len(train_set))[:12000]])
    train_y = torch.tensor([train_set[i][1] for i in torch.randperm(len(train_set))[:12000]])
    test_X = torch.stack([test_set[i][0] for i in torch.randperm(len(test_set))[:2500]])
    test_y = torch.tensor([test_set[i][1] for i in torch.randperm(len(test_set))[:2500]])

    if args.nodes > 1:
        hardware = ODCConstellation(args.nodes, config)
    else:
        hardware = OrbitalAIChip(config)

    trainer = OrbitalTrainer(hardware, lr=0.009)
    trainer.train(train_X, train_y, epochs=30, batch_size=128)

    if args.export_fpga:
        exporter = FPGAExporter(trainer.models[0], trainer.nodes[0])
        exporter.export()

    simulator = MissionSimulator(trainer.models[0], trainer.nodes[0])
    simulator.run(test_X, test_y, years=5.0)


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Orbital AI v13.2")
    parser.add_argument("--nodes", type=int, default=1)
    parser.add_argument("--seed", type=int, default=42)
    parser.add_argument("--export_fpga", action="store_true")
    args = parser.parse_args()

    torch.manual_seed(args.seed)
    random.seed(args.seed)
    run_demo(args)