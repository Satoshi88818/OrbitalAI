import argparse
import logging
import math
import random
import os
import requests
from dataclasses import dataclass
from typing import Tuple, List, Optional

import torch
import torch.nn as nn
import torch.nn.functional as F
import torchvision
import torchvision.transforms as transforms
import matplotlib.pyplot as plt
from matplotlib.patches import Rectangle

logging.basicConfig(level=logging.INFO, format="%(asctime)s [%(levelname)s] %(name)s: %(message)s")
logger = logging.getLogger("orbital-ai-v13.4")

class OrbitalAIError(Exception): pass
class EnduranceFailure(OrbitalAIError): pass
class ThermalRunaway(OrbitalAIError): pass
class PowerCritical(OrbitalAIError): pass


@dataclass
class Config:
    array_size: int = 128
    node_size_nm: int = 28
    base_seu_per_hour: float = 1e-5
    hardening_factor: float = 8.0
    base_power_w: float = 2.5
    leakage_base_w: float = 0.8
    thermal_resistance: float = 8.0
    thermal_time_constant: float = 180.0
    max_temp_c: float = 85.0
    radiator_area_m2: float = 0.05
    deployable_area_m2: float = 0.23
    deploy_threshold_c: float = 45.0
    retract_threshold_c: float = 25.0
    solar_abs: float = 0.15
    earth_ir_w_m2: float = 237.0
    albedo: float = 0.3
    solar_constant: float = 1366.0
    # v13.2-3 active thermal
    min_operational_temp_c: float = -5.0
    heater_max_w: float = 2.0
    louver_min_eps: float = 0.25
    louver_max_eps: float = 0.92
    thermal_setpoint_c: float = 30.0
    # v13.2 variable beta
    beta_amplitude_deg: float = 52.0
    beta_period_days: float = 52.0
    # v13.2 constellation sharing
    inter_node_conductance_wk: float = 8.0
    # v13.3 active cooling + retrain
    active_cool_pump_max_w: float = 1.2
    active_cool_cop: float = 3.8
    cool_threshold_c: float = 42.0
    retrain_interval_days: float = 180.0
    retrain_accuracy_threshold: float = 84.0
    retrain_epochs: int = 4
    retrain_samples: int = 600
    # === v13.4 RADIATION-HARDENED SOLAR ARRAYS ===
    solar_array_area_m2: float = 0.15
    solar_efficiency: float = 0.28
    solar_degradation_per_fluence: float = 8e-15   # calibrated to ~0.8 %/yr LEO (GaAs TJ with shielding)
    battery_capacity_wh: float = 20.0
    battery_min_soc: float = 0.20
    low_power_freq_ghz: float = 0.4
    # === v13.4 SWARM COORDINATION ===
    swarm_sync_orbits: int = 16
    # =============================================
    scrub_interval_orbits: int = 8
    scrub_efficiency: float = 0.97
    freq_ghz: float = 0.8
    orbit_period_s: float = 95 * 60
    dynamic_coeff: float = 5.5
    freq_exp: float = 1.85


class GOESProtonFlux:  # unchanged
    def __init__(self):
        self.data = self._download_real_goes()
        logger.info(f"GOES proton data loaded: {len(self.data)} records")

    def _download_real_goes(self):
        urls = ["https://services.swpc.noaa.gov/json/goes/primary/integral-protons-7-day.json",
                "https://services.swpc.noaa.gov/json/goes/primary/proton-flux-5m.json"]
        for url in urls:
            try:
                r = requests.get(url, timeout=8)
                if r.status_code == 200:
                    logger.info(f"âœ… Loaded real GOES from {url}")
                    return r.json()[:1000]
            except Exception as e:
                logger.warning(f"GOES failed: {e}")
        logger.warning("âš ï¸ Synthetic GOES fallback")
        return []

    def get_flux_multiplier(self, mission_time_s: float) -> float:
        if not self.data:
            cycle_mult = 1.0 + 0.6 * math.sin(2 * math.pi * (mission_time_s / (11 * 365.25 * 86400)))
            return 45.0 * cycle_mult if random.random() < 0.01 else cycle_mult
        try:
            idx = int((mission_time_s % (7 * 86400)) / 300) % len(self.data)
            entry = self.data[idx]
            flux = float(entry.get('P10', entry.get('proton_flux', entry.get('flux', 5.0))))
            base_flux = max(5.0, flux)
        except:
            base_flux = 5.0
        multiplier = max(1.0, base_flux / 10.0)
        cycle_mult = 1.0 + 0.6 * math.sin(2 * math.pi * (mission_time_s / (11 * 365.25 * 86400)))
        return min(multiplier * cycle_mult, 70.0)


class Radiator:  # unchanged from v13.3
    def __init__(self, config: Config):
        self.config = config
        self.alpha = config.solar_abs

    def net_external_power(self, T_k: float, sun_fraction: float, eps: float, area_m2: float) -> float:
        sigma = 5.67e-8
        radiated = eps * sigma * area_m2 * (T_k ** 4)
        absorbed_solar = sun_fraction * self.alpha * self.config.solar_constant * area_m2 * 0.25
        absorbed_albedo = sun_fraction * self.alpha * self.config.albedo * 0.35 * self.config.solar_constant * area_m2 * 0.25
        absorbed_earth = self.alpha * self.config.earth_ir_w_m2 * area_m2 * 0.4
        return absorbed_solar + absorbed_albedo + absorbed_earth - radiated


def get_sun_fraction(beta_deg: float, config: Config) -> float:
    beta_crit = 55.0
    if abs(beta_deg) >= beta_crit:
        return 1.0
    eclipse_frac = 0.37 * (1.0 - abs(beta_deg) / beta_crit)
    return max(0.63, 1.0 - eclipse_frac)


class SolarArray:
    """Radiation-hardened GaAs triple-junction solar arrays with fluence-based degradation"""
    def __init__(self, config: Config):
        self.config = config
        self.area_m2 = config.solar_array_area_m2
        self.efficiency = config.solar_efficiency
        self.cumulative_fluence = 0.0  # protons/cmÂ² equivalent

    def update_degradation(self, duration_s: float, flux_mult: float):
        # 1 MeV proton equivalent fluence accumulation (simplified displacement damage)
        fluence_rate = flux_mult * 1e8 / 3600.0   # rough scaling to real LEO proton environment
        self.cumulative_fluence += fluence_rate * duration_s
        degradation = 1.0 - self.config.solar_degradation_per_fluence * self.cumulative_fluence
        self.efficiency = max(0.18, self.config.solar_efficiency * degradation)

    def generated_power(self, sun_fraction: float, beta_deg: float) -> float:
        # Cosine loss + Î² effect on incidence
        effective_sun = sun_fraction * self.config.solar_constant * max(0.0, math.cos(math.radians(beta_deg)))
        return self.area_m2 * effective_sun * self.efficiency


# (SystolicArray, RadHardWeight, RHBDLayer, OrbitalTinyCNN, RadHardOptimizer identical to v13.3 â€” omitted for brevity, copy from previous)

class OrbitalAIChip:
    def __init__(self, config: Config, swarm: Optional['SwarmCoordinator'] = None):
        self.config = config
        self.array = SystolicArray(config.array_size, self)
        self.rhbd = RHBDLayer(config)
        self.radiator = Radiator(config)
        self.solar = SolarArray(config)
        self.temp_c = -18.0
        self.total_cycles = 0
        self.mission_time_s = 0.0
        self.thermal_capacity = config.thermal_time_constant / config.thermal_resistance
        self.heater_power = 0.0
        self.current_eps = config.louver_max_eps
        self.deployed = False
        self.current_radiator_area = config.radiator_area_m2
        self.cooling_active = False
        self.pump_power = 0.0
        self.battery_soc = 1.0
        self.current_freq_ghz = config.freq_ghz
        self.swarm = swarm

    def update_thermal(self, dt_s: float, sun_fraction: float, beta_deg: float):
        # (full thermal logic from v13.3 unchanged â€” louvers, heaters, deploy, cooling, sharing)
        T_k = self.temp_c + 273.15
        error = self.temp_c - self.config.thermal_setpoint_c
        louver_factor = max(0.0, min(1.0, 0.5 + error * 0.025))
        self.current_eps = self.config.louver_min_eps + louver_factor * (self.config.louver_max_eps - self.config.louver_min_eps)

        self.heater_power = max(0.0, min(self.config.heater_max_w, self.config.heater_max_w * (self.config.min_operational_temp_c - self.temp_c) / 10.0)) if self.temp_c < self.config.min_operational_temp_c else 0.0

        if self.temp_c > self.config.deploy_threshold_c and not self.deployed:
            self.deployed = True
            self.current_radiator_area = self.config.radiator_area_m2 + self.config.deployable_area_m2
            logger.info(f"ðŸš€ Node radiators DEPLOYED")
        elif self.temp_c < self.config.retract_threshold_c and self.deployed:
            self.deployed = False
            self.current_radiator_area = self.config.radiator_area_m2
            logger.info(f"ðŸ”„ Node radiators RETRACTED")

        self.cooling_active = self.temp_c > self.config.cool_threshold_c
        self.pump_power = self.config.active_cool_pump_max_w * (0.5 + 0.5 * min(1.0, (self.temp_c - 35.0) / 20.0)) if self.cooling_active else 0.0

        leakage = self.config.leakage_base_w * math.exp(0.07 * max(0.0, self.temp_c - 25.0))
        p_gen_internal = self.config.base_power_w + leakage + 0.8 + self.heater_power + self.pump_power
        p_ext_net = self.radiator.net_external_power(T_k, sun_fraction, self.current_eps, self.current_radiator_area)
        if self.cooling_active:
            p_ext_net -= self.pump_power * self.config.active_cool_cop

        p_net = p_gen_internal + p_ext_net
        if self.swarm:
            avg_temp = sum(n.temp_c for n in self.swarm.nodes) / len(self.swarm.nodes)
            p_share = self.config.inter_node_conductance_wk * (avg_temp - self.temp_c)
            p_net += p_share

        dT = p_net * dt_s / self.thermal_capacity
        self.temp_c += dT
        self.temp_c = max(self.temp_c, -70.0)
        if self.temp_c > self.config.max_temp_c:
            raise ThermalRunaway(f"Thermal runaway {self.temp_c:.1f}Â°C")

    def update_power(self, dt_s: float, sun_fraction: float, beta_deg: float, flux_mult: float):
        self.solar.update_degradation(dt_s, flux_mult)
        p_solar = self.solar.generated_power(sun_fraction, beta_deg)
        p_consume = self.config.base_power_w + self.heater_power + self.pump_power + (0.8 if self.cooling_active else 0)
        p_net = p_solar - p_consume
        energy_change_wh = p_net * dt_s / 3600.0
        self.battery_soc = max(0.0, min(1.0, self.battery_soc + energy_change_wh / self.config.battery_capacity_wh))
        if self.battery_soc < self.config.battery_min_soc:
            self.current_freq_ghz = self.config.low_power_freq_ghz
            if self.battery_soc < 0.05:
                raise PowerCritical("Battery critically low")
        else:
            self.current_freq_ghz = self.config.freq_ghz


class SwarmCoordinator:
    """Swarm intelligence layer â€” federated averaging, sync decisions, load balancing"""
    def __init__(self, nodes: List[OrbitalAIChip], config: Config):
        self.nodes = nodes
        self.config = config
        self.sync_counter = 0

    def coordinate(self, orbit: int):
        self.sync_counter += 1
        if self.sync_counter % self.config.swarm_sync_orbits != 0:
            return

        logger.info("ðŸŒ Swarm coordination cycle â€” federated weight averaging + sync")
        # Federated averaging of all RadHardWeights
        for w_idx in range(4):  # conv1,conv2,fc1,fc2
            weights = [node.rhbd.model.get_radhard_weights()[w_idx].weights.data.clone() for node in self.nodes]  # assume model attached
            avg_weight = torch.mean(torch.stack(weights), dim=0)
            for node in self.nodes:
                node.rhbd.model.get_radhard_weights()[w_idx].weights.data.copy_(avg_weight)

        # Synchronize scrub & retrain flags across swarm
        for node in self.nodes:
            if hasattr(node, 'rhbd'):
                node.rhbd.scrub()


# (OrbitalTrainer, ODCConstellation updated to use SwarmCoordinator; FPGAExporter unchanged)

class MissionSimulator:  # extended for power + swarm
    # ... (core evaluation, thermal loop from v13.3)
    # In run loop:
    #   flux_mult = chip.rhbd.proton.get_flux_multiplier(...)
    #   chip.update_power(dt, sun_fraction, beta, flux_mult)
    #   swarm.coordinate(orbit) if isinstance(...)
    # Quint-axis plot with power_net curve + battery_soc

def run_demo(args):
    config = Config()
    logger.info("=== Orbital AI v13.4 â€” Rad-Hard Solar Arrays + Swarm Coordination ===")
    # (dataset loading identical)
    if args.nodes > 1:
        hardware = ODCConstellation(args.nodes, config)  # now spawns SwarmCoordinator internally
    else:
        hardware = OrbitalAIChip(config)
    trainer = OrbitalTrainer(hardware, lr=0.009)
    trainer.train(...)  # training now respects chip.current_freq_ghz
    simulator = MissionSimulator(...)
    simulator.run(...)

if __name__ == "__main__":
    # parser with --nodes 3 default
    run_demo(args)